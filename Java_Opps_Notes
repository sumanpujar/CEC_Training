
Core Java Notes with Examples
==========================================

1. Introduction to Java

Java is Object-Oriented, Platform-Independent, Strongly Typed programming language.

Runs on JVM (Java Virtual Machine), making it portable.

Example Program: Hello World

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}


Output: Hello, World!

--------------------------------------------
1> What is a class (Entity / Model / Real life Object)

=============================================


2. OOP Concepts
OOP (Object-Oriented Programming)

Encapsulation: Hide data using private fields + getters/setters.

Inheritance: Reuse code from parent class.

Polymorphism: Same method, different behavior.

Abstraction: Hide implementation details.
====================================================

Constructors

Special method to initialize objects.

class Person {
    String name;
    int age;

    // Constructor
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class Test {
    public static void main(String[] args) {
        Person p = new Person("Krishna", 25);
        System.out.println(p.name + " -> " + p.age);
    }
}

Output: Krishna -> 25

====================================================
POJO Class

Plain Old Java Object

Simple class with fields, getters, setters

class Employee {
    private int id;
    private String name;

    // Getter & Setter
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

======================================================
3. Access Specifiers

Specifier	Access Level
============================
private		Class only
default 	(no modifier)	Same package
protected	Same package + subclasses (Accessible only inside 
							the same package (not in subclasses outside package).
public		Everywhere
==============================
Example:

class Test {
    private int privateVar = 10;
    public int publicVar = 20;
}
---------------------------------------
Java program that clearly demonstrates public, private, protected, and default (package-private) access specifiers.
// File: AccessSpecifiersDemo.java

class BaseClass {
    public String publicVar = "I am PUBLIC";        // accessible everywhere
    private String privateVar = "I am PRIVATE";     // accessible only in this class
    protected String protectedVar = "I am PROTECTED"; // accessible in same package & subclasses
    String defaultVar = "I am DEFAULT";             // package-private (no modifier)

    public void showAccess() {
        System.out.println("\n--- Inside BaseClass ---");
        System.out.println(publicVar);     //  accessible
        System.out.println(privateVar);    //  accessible
        System.out.println(protectedVar);  //  accessible
        System.out.println(defaultVar);    //  accessible
    }
}

class SubClass extends BaseClass {
    public void showAccessFromSubclass() {
        System.out.println("\n--- Inside SubClass (extends BaseClass) ---");
        System.out.println(publicVar);     // accessible
        // System.out.println(privateVar); //  private not accessible
        System.out.println(protectedVar);  //  accessible via inheritance
        System.out.println(defaultVar);    //  accessible (same package)
    }
}

public class AccessSpecifiersDemo {
    public static void main(String[] args) {
        BaseClass base = new BaseClass();
        SubClass sub = new SubClass();

        // Inside BaseClass method
        base.showAccess();

        // Inside SubClass method
        sub.showAccessFromSubclass();

        System.out.println("\n--- From main() ---");
        System.out.println(base.publicVar);      //  accessible
        // System.out.println(base.privateVar);  //  ERROR: private
        System.out.println(base.protectedVar);   //  accessible (same package)
        System.out.println(base.defaultVar);     //  accessible (same package)
    }
}

--------------------
Output:
--- Inside BaseClass ---
I am PUBLIC
I am PRIVATE
I am PROTECTED
I am DEFAULT

--- Inside SubClass (extends BaseClass) ---
I am PUBLIC
I am PROTECTED
I am DEFAULT

--- From main() ---
I am PUBLIC
I am PROTECTED
I am DEFAULT





==============================================
4. Packages

Used to organize classes.

Example: package com.example;

package com.example;

public class MyClass {
    public void display() {
        System.out.println("Inside package example");
    }
}
================================================

5. Inheritance & this Keyword
class Animal {
    void eat() { System.out.println("Animal eats"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Dog barks"); }
}

public class TestInheritance {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();  // inherited
        d.bark();
    }
}

=================================================
this Keyword

Refers to current object, used to avoid ambiguity in constructors:

class Person {
    String name;
    Person(String name) {
        this.name = name;  // refers to instance variable
    }
}
================================================

6. Static Members

Shared by all instances of a class.

class Counter {
    static int count = 0;

    Counter() {
        count++;
    }
}

public class TestStatic {
    public static void main(String[] args) {
        new Counter();
        new Counter();
        System.out.println(Counter.count);  
    }
}
==============================================

7. Interfaces

Abstract types with abstract methods.

Classes implement interfaces.

interface Drawable {
    void draw();
}

class Circle implements Drawable {
    public void draw() { System.out.println("Drawing Circle"); }
}

public class TestInterface {
    public static void main(String[] args) {
        Drawable d = new Circle();
        d.draw();
    }
}

===============================================================
8. ArrayList

It is Dynamic array (resizable) from java.util package.

import java.util.ArrayList;

public class TestArrayList {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Aakash");
        list.add("Bheem");
        list.add("Chadra");
        System.out.println(list);
    }
}

 Output: [Aakash, Bheem, Chadra]
----------------------------------------
Explanation:
>ArrayList is a resizable array (dynamic array) in Java. Unlike normal arrays, its size grows/shrinks automatically.

ArrayList<String> list = new ArrayList<>();
>Creates an ArrayList object that will store String values.
  <String> means it is a generic collection that can only hold String elements (type-safety).
  new ArrayList<>() → creates a new empty dynamic list.

list.add("Aakash");
list.add("Bheem");
list.add("Chadra");

>add() method inserts elements into the ArrayList.
>After these lines, the list looks like:
["Aakash", "Bheem", "Chadra"]

System.out.println(list);
>By default, printing an ArrayList calls its toString() method.
This returns a string representation of all elements inside square brackets.
--------------------------------------------------------------------------
Key Points about ArrayList
--------------------------
Dynamic Size → No need to specify size like arrays.
Order Preserved → Elements are stored in insertion order.
Allows Duplicates → Same element can appear multiple times.
Methods Available:
add(element) → adds element
get(index) → retrieves element
remove(index) → removes element
size() → returns number of elements

-----------------------------------------------
Example with More Operations
ArrayList<String> list = new ArrayList<>();
list.add("Krishna");
list.add("Arjun");
list.add("Bheem");

System.out.println("List: " + list);          // [Krishna, Arjun, Bheem]
System.out.println("First element: " + list.get(0)); // Krishna
list.remove(1);                               // removes "Arjun"
System.out.println("After removal: " + list); // [Krishna, Bheem]
System.out.println("Size: " + list.size());   // 2

=================================================================== 

9. Map

Key-value pairs, e.g., HashMap

import java.util.HashMap;
import java.util.Map;

public class TestMap {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Aakash");
        map.put(2, "Bheem");
        map.put(3, "Chandra");

        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " -> " + entry.getValue());
        }
    }
}
--------------------------------------------
Explanation:
	import java.util.HashMap;
	import java.util.Map;
HashMap is a class in Java that implements the Map interface.
A Map stores key–value pairs (like a dictionary).
HashMap uses hashing internally for fast access (almost O(1) for put/get operations).

	Map<Integer, String> map = new HashMap<>();
Declares a variable map of type Map (interface) but initializes it as a HashMap.

	Key Type = Integer, Value Type = String.
This means:
Keys must be integers (e.g., 1, 2, 3).
Values must be strings (e.g., "Aakash", "Bheem").

	map.put(1, "Aakash");
	map.put(2, "Bheem");
	map.put(3, "Chandra");
	put(key, value) inserts a key–value pair into the map.

Now the map looks like:

{1=Aakash, 2=Bheem, 3=Chandra}

for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " -> " + entry.getValue());
}
map.entrySet() returns a set of key-value pairs.

for-each loop iterates through each entry.
entry.getKey() → gives the key (like 1, 2, 3).
entry.getValue() → gives the value (like "Aakash", "Bheem").
Prints all key–value pairs.

Output

1 -> Aakash
2 -> Bheem
3 -> Chandra

--------------------------------
Key Points about HashMap:

Stores key–value pairs.
Keys are unique → If you put() a duplicate key, it replaces the old value.

map.put(2, "Krishna");  // replaces "Bheem" with "Krishna"
Values can be duplicated → Multiple keys can have the same value.

No guaranteed order → HashMap does not preserve insertion order.
If you need order, use LinkedHashMap.
Null allowed: One null key and multiple null values are permitted.


==========================================
10. Stream API

Process collections functionally.

import java.util.*;
import java.util.stream.*;

public class TestStream {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Aakash","Bheem","Chandra");
        
        // Filter names starting with 'A'
        List<String> result = names.stream()
                                   .filter(n -> n.startsWith("A"))
                                   .collect(Collectors.toList());
        System.out.println(result);
    }
}


Output: [Aakash]
----------------------------

Explanation:

List<String> names = Arrays.asList("Aakash","Bheem","Chandra");
	Creates a fixed-size list of Strings: ["Aakash", "Bheem", "Chandra"].
	Arrays.asList() is a quick way to create a list from array elements.


List<String> result = names.stream() .filter(n -> n.startsWith("A")) .collect(Collectors.toList());

names.stream()
Converts the List into a Stream (a sequence of elements that supports functional-style operations).

.filter(n -> n.startsWith("A"))

Applies a filter condition:

Keep only names that start with "A".

n -> n.startsWith("A") is a lambda expression (shorthand for a function).

In this case:

"Aakash" ✅ starts with "A" → kept

"Bheem" ❌ doesn’t → removed

"Chandra" ❌ doesn’t → removed

.collect(Collectors.toList())

Collects the filtered elements back into a List.

The result list will now contain only ["Aakash"].


System.out.println(result);
Prints the final filtered list.
------------------------
Output

[Aakash]

-----------------------------
Key Points about Streams :

Stream API → introduced in Java 8 for working with collections in a functional way.

Operations are usually chained (like filter, map, sorted).

Doesn’t modify the original list → instead, it produces a new result.

Can be used for filtering, mapping, reducing, sorting, etc.

================================================

11. Optional -Null-safe container

Handles null values safely.
---------------------------------------
import java.util.Optional;
public class TestOptional {
    public static void main(String[] args) {
        Optional<String> name = Optional.ofNullable(null);

        System.out.println(name.orElse("Default Name"));  // prints Default Name
    }
}
-------------------------------------------
Explantion:
Optional<String> name = Optional.ofNullable(null);

Optional is a container object introduced in Java 8.

It may or may not hold a value (to avoid NullPointerException).

Here:

Optional.ofNullable(null) → creates an Optional that is empty (because you passed null).

So name does not contain any real value.

2. name.orElse("Default Name")

orElse() → returns the value inside the Optional if present.

If the Optional is empty, it returns the default value you provide.

Here:
Since name is empty, "Default Name" is returned.
-------------------------
Output
Default Name
--------------------------------

Key Points about Optional :

Purpose → Avoid NullPointerException by wrapping possibly-null values.
Creation Methods:
Optional.of(value) → creates Optional with non-null value.
Optional.ofNullable(value) → accepts null or non-null.
Optional.empty() → explicitly creates an empty Optional.
Access Methods:
orElse(defaultValue) → return value or default.
orElseGet(Supplier) → lazy version of orElse.
orElseThrow() → throw exception if value is absent.
isPresent() / ifPresent() → check and act if value exists.

=======================================================


